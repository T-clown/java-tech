[Redlock：Redis分布式锁最牛逼的实现](https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ)
[](https://www.yht7.com/news/2473)

###高效分布式锁需要满足的一些条件
    1.互斥：在分布式高并发的条件下，我们最需要保证，同一时刻只能有一个线程获得锁，这是最基本的一点
    2.防止死锁：在分布式高并发的条件下，比如有个线程获得锁的同时，还没有来得及去释放锁，就因为系统故障或者其它原因使它无法执行释放锁的命令,导致其它线程都无法获得锁，造成死锁。
              所以分布式非常有必要设置锁的有效时间，确保系统出现故障后，在一定时间内能够主动去释放锁，避免造成死锁的情况
    3.性能：对于访问量大的共享资源，需要考虑减少锁等待的时间，避免导致大量线程阻塞。所以在锁的设计时，需要考虑两点
            锁的颗粒度要尽量小。比如你要通过锁来减库存，那这个锁的名称你可以设置成是商品的ID,而不是任取名称。这样这个锁只对当前商品有效,锁的颗粒度小。
            锁的范围尽量要小。比如只要锁2行代码就可以解决问题的，那就不要去锁10行代码了
    4.重入：同一个线程可以重复拿到同一个资源的锁。重入锁非常有利于资源的高效利用
    
###Redisson原理分析
    1.加锁机制
        线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。
        线程去获取锁，获取失败: 一直通过while循环尝试获取锁，获取成功后，执行lua脚本，保存数据到redis数据库。
    2.watch dog自动延期机制
        启动一个watch dog后台线程，不断的延长锁key的生存时间，一般不开启，会影响性能
    3.为啥要用lua脚本呢？
        保证命令的原子性
    4.可重入加锁机制
        Redis存储锁的数据类型是 Hash类型，Hash数据类型的key值包含了当前线程信息

###Redis分布式锁的缺点
    在Redis哨兵模式下:客户端1 对某个master节点写入了redisson锁，此时会异步复制给对应的 slave节点。但是这个过程中一旦发生 master节点宕机，主备切换，slave节点从变为了 master节点。
    这时客户端2 来尝试加锁的时候，在新的master节点上也能加锁，此时就会导致多个客户端对同一个分布式锁完成了加锁。这时系统在业务语义上一定会出现问题，导致各种脏数据的产生
    缺陷在哨兵模式或者主从模式下，如果 master实例宕机的时候，可能导致多个客户端同时完成加锁
    解决办法：用RedLock红锁