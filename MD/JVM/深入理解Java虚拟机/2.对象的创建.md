###对象的创建
        当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到
    一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那
    必须先执行相应的类加载过程，在类加载检查通过后，接下来虚拟机将为新生对象分配内存，对象所需内存的大小在类加载完成后便可完全确定
        内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果
    使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段
    在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值
        接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到
    类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才
    计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟
    机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式

##内存分配策略
###1.指针碰撞（Bump The Pointer）    
        假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，
    那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”
    
    解决并发情况：
    1.一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；
    2.另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation
    Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完
    了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。

###2.空闲列表”（Free List）
        如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那
     就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分
     配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称
     为“空闲列表”
     
    选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用
    的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩
    整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除
    （Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存