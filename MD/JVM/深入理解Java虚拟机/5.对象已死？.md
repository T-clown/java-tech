### 1.引用计数算法（Reference Counting）
- 在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；
  任何时刻计数器为零的对象就是不可能再被使用的
- 缺点：很难解决对象之间相互循环引用的问题
---
### 2.可达性分析（Reachability Analysis）算法
- 通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过
    程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，
    或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的
    固定可作为GC Roots的对象包括以下几种：
    1. 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
    2. 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
    3. 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
    4. 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
    5. Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
    6. 所有被同步锁（synchronized关键字）持有的对象。
    7. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
---
### 引用类型 这4种引用强度依次逐渐减弱。
- 强引用（Strongly Re-ference）
        类似“Objectobj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象
- 软引用（Soft Reference）
        软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，
        如果这次回收还没有足够的内存，才会抛出内存溢出异常
- 弱引用（Weak Reference）
        弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只
        能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象
- 虚引用（Phantom Reference）
        虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。
        一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚
        引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知
### 判定一个类型是否属于“不再被使用的类”需要同时满足下面三个条件：
- 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例
- 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
