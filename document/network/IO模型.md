### 直接I/O和缓冲I/O

- 缓冲I/O是C语⾔ 提供的库函数，均以f打头
- 直接I/O是Linux的系统API

- 应⽤程序内存：是通常写代码⽤malloc/free、new/delete等分配出来的 内存。 ⽤户缓冲区：C语⾔的FILE结构体⾥⾯的buffer
- 内核缓冲区：Linux操作系统的Page Cache。为了加快磁盘的I/O， Linux系统会把磁盘上的数据以Page为单位缓存在操作系统的内存⾥，这⾥ 的Page是Linux系统定义的⼀个逻辑概念，⼀个Page⼀般为4K。

- 对于缓冲I/O，⼀个读操作会有3次数据拷贝，⼀个写操作，有反向的3 次数据拷贝：
    - 读：磁盘→内核缓冲区→⽤户缓冲区→应⽤程序内存；
    - 写：应⽤程序内存→⽤户缓冲区→内核缓冲区→磁盘。

- 对于直接I/O，⼀个读操作，会有2次数据拷贝，⼀个写操作，有反向 的2次数据拷贝：
    - 读：磁盘→内核缓冲区→应⽤程序内存；
    - 写：应⽤程序内存→内核缓冲区→磁盘。

- 所以，所谓的“直接I/O”，其中直接的意思是指没有⽤户级的缓冲，但 操作系统本⾝的缓冲还是有的

- fflush和fsync的区别： fflush是缓冲I/O中的⼀个API，它只是把数 据从⽤户缓冲区刷到内核缓冲区⽽已，fsync则是把数据从内核缓冲区刷到 磁盘⾥。

### 内存映射⽂件与零拷贝

- 内存映射文件：当⽤ 户空间不再有物理内存，直接拿应⽤程序的逻辑内存地址映射到 Linux 操 作系统的内核缓冲区，应⽤程序虽然读写的是⾃⼰的内存，但这个内存只 是⼀个“逻辑地址”，实际读写的是内核缓冲区！

数据拷贝次数从缓冲I/O的3次，到直接I/O的2次，再到内存映射⽂ 件，变成了1次。 - 读：磁盘→内核缓冲区； - 写：内核缓冲区→磁盘

- 零拷贝：零拷贝（Zero Copy）是提升I/O效率的又⼀利器，熟悉Kafka实现原理 的⼯程师应该知道，在消费消息的时候利⽤了零拷贝技术 对于把⽂件数据发送到⽹络的这个场景，直接I/O、内
  存映射⽂件、零拷贝对应的数据拷贝次数分别是4次、3次、2次，内存拷 贝次数分别是2次、1次、0次。 零拷贝，实际是 2 次数据拷贝，1 次是从磁 盘到内核缓冲区，1次是从内核缓冲区到⽹络。之所以叫零拷贝，是从内
  存的⾓度来看的，数据在内存中没有发⽣过数据拷贝，只在内存和I/O之间 传输。

### ⽹络I/O模型

1. 同步阻塞I/O：是Linux系统的read和write函数，在调⽤的时候会被阻塞，直到数据读取完成，或者写⼊成功
2. 同步⾮阻塞I/O：和 同 步 阻 塞 I/O 的 API 是 ⼀ 样 的 ， 只 是 打 开 fd 的 时 候 带 有 O_NONBLOCK参数。于是，当调⽤read和write函数的时候，如果没有准
   备好数据，会理解返回，不会阻塞，然后让应⽤程序不断地去轮询
3. I/O多路复⽤（IO Multiplexing）（同步阻塞）
   (1)select
   (2)poll
   (3)epoll
   (4)Java的NIO I/O多路复⽤是现在Linux系统上最成熟的⽹络I/O模型，在三种⽅式 中，epoll的效率最⾼，所以⽬前主流的⽹络模型都是epoll。
4. 异步I/O：所谓异步I/O，是指读写都是由操作系统完成的，然后通过回调函数或者某种其他通信机制通知应⽤程序，如:
   (1)Windows系统的IOCP
   (2)C++中的 asio⽹络库
   (3)Linux aio “异步”，就是读写由底层完成（操作系统或者框架），读写完成之后， 以某种⽅式通知应⽤程序

### 阻塞和⾮阻塞、同步和异步：

- 阻塞和⾮阻塞是从函数调⽤角度来说的，⽽同步和异步是从“读 写是谁完成的”角度来说的。
    1. 阻塞：如果读写没有就绪或者读写没有完成，则该函数⼀直等待。
    2. ⾮阻塞：函数⽴即返回，然后让应⽤程序轮询。
    3. 同步：读写由应⽤程序完成。
    4. 异步：读写由操作系统完成，完成之后，回调或者事件通知应⽤程 序。
- 按照这个定义可以知道，异步I/O⼀定是⾮阻塞I/O，不存在既是 异步I/O，又是阻塞的；同步I/O可能是阻塞的，也可能是⾮阻塞的。 归类后共有三种：同步阻塞I/O、同步⾮阻塞I/O、异步I/O。
- I/O多路复⽤（select、poll、epoll）都是同步I/O，因为read和 write函数操作都是应⽤程序完成的，同时也是阻塞I/O，因为select、 read、write的调⽤都是阻塞的。
- 对于“异步I/O”⼀词，在操作系统的语境和在上层应⽤的语境 中，往往指代不⼀样。在操作系统的语境⾥，异步I/O是指IOCP或者aio这 种真正的异步，epoll不被认为是异步I/O；但在上层应⽤的语境⾥，异步
  I/O往往指的是JavaJDK或⽹络框架（Netty）封装出来的概念，底层实现可 能是epoll，也可能是真正的异步I/O

### Reactor模式与Preactor模式

- Reactor模式：主动模式。所谓主动，是指应⽤程序不断地轮询，询问操作系统或者⽹络框架、I/O是否就绪。Linux系统下的select、 poll、epoll就属于主动模式，需要应⽤程序中有⼀个循环⼀直轮询；Java中
  的NIO也属于这种模式。在这种模式下，实际的I/O操作还是应⽤程序执⾏的。
- Proactor模式：被动模式。应⽤程序把read和write函数操作全部 交给操作系统或者⽹络框架，实际的 I/O 操作由操作系统或⽹络框架完 成，之后再回调应⽤程序。asio 库就是典型的Proactor模式

#### 服务器编程的1+N+M模型

- 在服务器的编程中，epoll编程的三个步骤是由不同的线程负责的，即 服务器编程的1+N+M模型。 整个服务器有1+N+M个线程，⼀个监听线程，N个I/O 线程，M个Worker线程。N的个数通常等于CPU核数，M的个数根据上层决
  定，通常有⼏百个。
- Redis就是单进程单线程的模型（这⾥说的单 线程模型，不是指整个Redis服务器只有⼀个线程，⽽是指接收并处理客户 端请求的线程只有⼀个）。之所以单线程可以⽀持，是因为在请求接收的
  地⽅⽤的是epoll的I/O多路复⽤，在请求处理的地⽅又完全是内存操作，没 有磁盘或者⽹络I/O，所以只需单线程就⾜够了
- Nginx有⼀个Master进程，N个 Worker进程，每个Worker进程对应⼀个CPU核，每个进程都是单线程的。 Master进程不接收请求，负责管理功能；各个Worker 进程间相互独⽴，并
  ⾏地接收客户端的请求，也不需要像多线程那样在不同的 CPU 核间切 换。

### ⽆锁（内存屏障与CAS）

- “重排序”，通俗地讲，就是CPU不会按照开发者写的代码顺序来 执⾏
- 在多核CPU体系下，每个CPU有 ⾃⼰的缓存！改过的这个值可能还在CPU的缓存⾥，没有刷新到内存⾥。内存屏障就是要强制把这个值刷新到内存⾥⾯。
- CAS是 在CPU层⾯提供的⼀个硬件原⼦指令，实现对同⼀个值的Compare和Set 两 个操作的原⼦化。
