[阿里终面：分布式事务原理](https://mp.weixin.qq.com/s/b7s-xbJX56bqo49QG1U7Rw)
[](https://mp.weixin.qq.com/s/sXVSFqq2UZ6Pwwt7vx7vIA)
[](https://mp.weixin.qq.com/s/VIuJ5ywyjfGjAWd3Fb-XWg)

### CAP理论

1. 一致性（Consistency）：一致性要求系统的所有节点在同一时刻看到的数据是相同的。在一个一致性的系统中，当数据被更新后，所有的节点都能够立即获取到最新的数据。
2. 可用性（Availability）：可用性要求系统在正常情况下能够提供服务并响应用户的请求。在一个可用性的系统中，用户能够随时访问系统并获取到响应，即使系统中的部分节点发生故障或失效
3. 分区容错性（Partition Tolerance）：分区容错性指的是系统在面对网络分区（节点之间无法通信）或节点故障的情况下仍能够正常运行

### BASE 理论

1. 基本可用（BasicallyAvailable）： 分布式系统在出现故障时，允许损失部分的可用性来保证核心可用
2. 软状态（SoftState）：允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性
   （系统中的数据和状态可以在一段时间内是不确定的，即在没有外部输入的情况下，系统的状态可能会发生变化。这是因为分布式系统中的数据副本可能在不同的节点之间进行异步复制或延迟同步，导致数据的一致性不是实时的）
3. 最终一致性（EventualConsistency）： 分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态

### 1.2PC

1. 2PC 有两个角色
    - 事务协调者。调用方也就是协调者
    - 事务参与者。具体到数据库的实现来说，每一个数据库就是一个参与者
2. 2PC 两个阶段
    - 阶段 1：准备阶段。协调者向各个参与者发起询问，说要执行一个事务，各参与者可能回复YES、NO或超时
    - 阶段 2：提交阶段。
        - 如果所有参与者都回复的是 YES，则事务协调者向所有参与者发起事务提交操作，即Commit操作，所有参与者各自执行事务，然后发送ACK。
        - 如果有一个参与者回复的是 NO，或者超时了，则事务协调者向所有参与者发起事务回滚操作，所有参与者各自回滚事务，然后发送ACK
3. 2PC的问题
    - 问题1：性能问题。在阶段1，锁定资源之后，要等所有节点返回，然后才能一起进入阶段2，不能很好地应对高并发场景
    - 问题2：阶段1完成之后，如果在阶段2事务协调者宕机，则所有的参与者接收不到Commit或Rollback指令，将处于“悬而不决”状态
    - 问题3：阶段1完成之后，在阶段2，事务协调者向所有的参与者发送了Commit指令，但其中一个参与者超时或出错了（没有正确返回ACK），则其他参与者提交还是回滚呢？也不能确定
    - 问题4：它主要用在两个数据库之间（数据库实现了XA协议）。但以支付宝的转账为例，是两个系统之间的转账，而不是底层两个数据库之间直接交互，所以没有办法使用2PC

### 最终一致性（消息中间件）

1. 方案一：基于kafka（不支持事务消息）
    - 步骤1：系统A增加一张消息表，系统A不再直接给消息中间件发送消息，而是把消息写入到这张消息表中。把DB1的扣钱操作（表1）和写入消息表（表2）这两个操作放在一个数据库事务里，保证两者的原子性
    - 步骤2：系统A准备一个后台程序，源源不断地把消息表中的消息传送给消息中间件。如果失败了，也不断尝试重传。因为网络的2将军问题，系统A发送给消息中间件的消息网络超时了，消息中间件可能已经收到了消息，也可能没有收到。
      系统A会再次发送该消息，直到消息中间件返回成功。所以，系统A允许消息重复，但消息不会丢失，顺序也不会打乱
    - 消息消费问题：
        - 消费端丢失消费：通过消息中间件的ACK机制（手动提交，防止消费过程中异常），凡是发送ACK的消息，系统B重启之后消息中间件不会再次推送；凡是没有发送ACK的消息，系统B重启之后消息中间件会再次推送
        - 重复消费：通过业务属性进行幂等判断，如果没有唯一业务熟悉则消费端需要增加判重表，每次消费进行判重


3. 方案二：基于RocketMQ（支持事务消息）使用较广
    - 步骤1：系统A调用Prepare接口，预发送消息。此时消息保存在消息中间件里，但消息中间件不会把消息给消费方消费，消息只是暂存在那
    - 步骤2：系统A更新数据库，进行扣钱操作
    - 步骤3：系统A调用Confirm接口，确认发送消息。此时消息中间件才会把消息给消费方进行消费
    - RocketMQ会定期（默认是1min）扫描所有的预发送但还没有确认的消息，回调给发送方，询问这条消息是要发出去，还是取消。发送方根据自己的业务数据，知道这条消息是应该发出去（DB更新成功了），还是应该取消（DB更新失败）

4. 消费失败解决方案：重试+人工处理

### TCC（TCC框架）强一致性

1. TCC是Try、Confirm、Cancel三个单词的缩写，其实是一个应用层面的2PC协议

2. TCC两个阶段
    - 准备阶段：调用方调用所有服务方提供的Try接口，该阶段各调用方做资源检查和资源锁定，为接下来的阶段2做准备
    - 提交阶段：如果所有服务方都返回 YES，则进入提交阶段，调用方调用各服务方的Confirm接口，各服务方进行事务提交。如果有一个服务方在阶段1返回NO或者超时了，则调用方调用各服务方的Cancel接口

3. TCC是通过不断重试来解决调用方发生宕机或者某个服务超时的问题，不管是Confirm失败了，还是Cancel失败了，都不断重试。这就要求Confirm和Cancel都必须是幂等操作。
   注意，这里的重试是由TCC的框架来执行的，而不是让业务方自己去做
4. 使用场景：对一致性要求高，一般来说和钱相关的支付、交易等相关的场景，会用TCC

### 事务状态表+调用方重试+接收方幂等（业务方自己实现）

1. 调用方维护一张事务状态表（或者说事务日志、日志流水），在每次调用之前，落盘一条事务流水，生成一个全局的事务ID
2. 初始是状态1，每调用成功1个服务则更新1次状态，最后所有系统调用成功，状态更新到状态4，状态2、3是中间状态。
   当然，也可以不保存中间状态，只设置两个状态：Begin和End。事务开始之前的状态是Begin，全部结束之后的状态是End。如果某个事务一直停留在Begin状态，则说明该事务没有执行完毕
3. 然后有一个后台任务，扫描状态表，在过了某段时间后（假设1次事务执行成功通常最多花费30s），状态没有变为最终的状态4，说明这条事务没有执行成功。于是重新调用系统A、B、C。保证这条流水的最终状态是状态4（或 End 状态）。
   当然，系统 A、B、C根据全局的事务ID做幂等操作，所以即使重复调用也没有关系

### 本地消息表（基于kafka）（不适合高并发场景）

1. A系统在本地一个事务里操作的同时，插入一条数据到消息表
2. 接着A系统将这个消息发送到MQ
3. B系统接收到消息后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息
4. B系统执行成功后，就会更新自己本地消息表的状态以及A系统消息表的状态
5. 如果B系统处理失败，那么就不会更新消息表状态，那么此时A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到MQ中去，让B再处理

### Seata分布式事务框架

[](https://seata.io/zh-cn/docs/overview/what-is-seata.html)

1. AT模式（两阶段提交协议的演变）
    - 一阶段 prepare 行为：在本地事务中，一并提交业务数据更新和相应回滚日志记录
    - 二阶段 commit 行为：马上成功结束，自动 异步批量清理回滚日志
    - 二阶段 rollback 行为：通过回滚日志，自动 生成补偿操作，完成数据回滚
    - 基于 支持本地 ACID 事务 的 关系型数据库
2. TCC模式（业务侵入性强，但灵活性高）
    - 不依赖于底层数据资源的事务支持
    - 一阶段 prepare 行为：调用 自定义 的 prepare 逻辑
    - 二阶段 commit 行为：调用 自定义 的 commit 逻辑
    - 二阶段 rollback 行为：调用 自定义 的 rollback 逻辑
3. Saga模式（长事务解决方案）
    - 使用场景：业务流程长、业务流程多
    - 缺点：不保证隔离性
4. XA模式






