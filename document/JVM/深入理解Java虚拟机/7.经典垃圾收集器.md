![垃圾收集器](/document/image/垃圾收集器.png)

### 新生代收集器

##### java -XX:+PrintCommandLineFlags -version查看垃圾收集器

**JDK1.8中默认使用的是Parallel Scavenge和Parallel Old收集器组合**

1. Serial
    - 单线程，并且它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。
    - 标记-复制算法
    - 适用场景：客户端(Client) 模式（桌面应用）；单核服务器时最适合；与CMS 收集器搭配使用。

2. ParNew
    - Serial 的多线程版本，多线程
    - 标记-复制算法
    - 适用场景：多核服务器；与CMS 收集器搭配使用。
    - 当使用 -XX:+UserConcMarkSweepGC 来选择 CMS 作为老年代收集器时，新生代收集器默认就是 ParNew， 也可以用 -XX:+UseParNewGC 来指定使用 ParNew 作为新生代收集器

3. Parallel Scavenge（关注吞吐量）
    - 并行收集的多线程收集器，吞吐量优先
    - 基于标记-复制算法实现的收集器，自适应调节策略
    - 适用场景：注重吞吐量，高效利用 CPU，需要高效运算且不需要太多交互

#### CMS和Parallel Scavenge的区别

- CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。
  所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值，即： 吞吐量=运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)
  停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验； 而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。

- Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是：

1. 控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数。 -XX：MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的
   时间不超过用户设定值。不过大家不要异想天开地认为如果把这个参数的值设置得更小一点就能使得 系统的垃圾收集速度变得更快，垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的：
   系统把新生代调得小一些，收集300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得 更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间 的确在下降，但吞吐量也降下来了。
2. 直接设置吞吐量大小的-XX：GCTimeRatio参数。 -XX：GCTimeRatio参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的
   比率，相当于吞吐量的倒数。譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5% （即1/(1+19)），默认值为99，即允许最大1%（即1/(1+99)）的垃圾收集时间

自适应调节策略：参数-XX：+UseAdaptiveSizePolicy

### 老年代收集器

1. Serial Old
    - Serial收集器的老年代版本，单线程收集器
    - 采用标记-整理算法
    - 适用场景：客户端模式(Client)（桌面应用）；单核服务器；
        1. 与 Parallel Scavenge 收集器搭配使用；
        2. 作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用

2. Parallel Old
    - Parallel Scavenge 的老年代版本，是一个多线程收集器
    - 采用标记-整理算法
    - 适用场景：与Parallel Scavenge 收集器搭配使用；注重吞吐量(1.8默认)或者处理器资源较为稀缺的场合

3. CMS（Concurrent Mark Sweep） CMS收集器是一种以获取最短回收停顿时间为目标的收集器
    - 特点：并发收集，用户线程无需停留
    - 标记-清除算法
    - 适用场景：重视服务器响应速度，要求系统停顿时间最短。可以使用 -XX:+UserConMarkSweepGC 来选择 CMS 作为老年代收集器
    - 清除步骤：
        1. 初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”
        2. 并发标记（CMS concurrent mark）：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程
        3. 重新标记（CMS remark）：重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要“Stop The World”
        4. 并发清除（CMS concurrent sweep）：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。
    - 缺点：
        1. 在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计 算能力）而导致应用程序变慢，降低总吞吐量。
        2. 并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，这些就是浮动垃圾，由于CMS收集器无法处理“浮动垃圾”（Floating
           Garbage），有可能出现“Con-current ModeFailure”失败进而导致另一次完全“Stop The World”的Full GC的产生
        3. 基于“标记-清除”算法实现，这意味着收集结束时会有大量空间碎片产生

4. G1 Garbage First(1.9默认)
    - 特点：并发，并行
    - 标记-整理算法
    - 适用场景：面向服务端应用，要求尽可能可控 GC 停顿时间；内存占用较大的应用
    - 清除步骤：
        1. 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要
           停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际 并没有额外的停顿，Stop The World
        2. 并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以
           后，还要重新处理SATB记录下的在并发时有引用变动的对象
        3. 最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录，Stop The World
        4. 筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回
           收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧
           Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的，Stop The World

    - G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以 根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间
      Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX：G1HeapRegionSize设
      定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代
      的一部分来进行看待 虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区
      域（不需要连续）的动态集合，G1收集器跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），
      优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。

### 低延迟垃圾收集器

- 衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency）

### 1.Shenandoah收集器

### 2.ZGC收集器

- ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。

### 并行和并发

- 并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。
-

并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。


    