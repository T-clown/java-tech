### Sentinel(哨兵)（保证Redis的高可用性（high availability））

- Redis Sentinel（哨岗、哨兵）是Redis的高可用性（high availability）解决方案：由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，
  以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求
- 检测主观下线状态
    - 在默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线
    - 如果一个实例在down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，则Sentinel会将此实例标记为主观下线
- 检查客观下线状态
    - 当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态（可以是主观下线或者客观下线）
    - 当Sentinel从其他Sentinel那里接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，并对主服务器执行故障转移操作
    - 当认为主服务器已经进入下线状态的Sentinel的数量，超过Sentinel配置中设置的quorum参数的值，那么该Sentinel就会认为主服务器已经进入客观下线状态
- 选举领头Sentinel
    - 当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作
- 故障转移
    1. 在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。
        - 过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节点ping响应、与主节点失联超过down-after-milliseconds*10秒
        - 领头Sentinel将根据从服务器的优先级（由高到底），复制偏移量（从大到小），运行id（从小到大）进行排序，选择第一个
    2. 让已下线主服务器属下的所有从服务器改为复制新的主服务器。
    3. 将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器

### Redis集群(Redis Cluster)

- Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能
- 当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的
- 数据分布理论
    1. 节点取余分区：使用特定的数据，如Redis的键或用户ID，再根据节点数量N使用公式：hash（key）%N计算出哈希值，用来决定数据映射到哪一个节点上
        - 优点：简单，常用于数据库的分库分表规则，一般采用预分区的方式，提前根据数据量规划好分区数
        - 缺点：当节点数量变化时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移
    2. 普通一致性哈希分区：一致性哈希分区（Distributed Hash Table）实现思路是为系统中每个节点分配一个token，范围一般在0~232
       ，这些token构成一个哈希环。数据读写执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点
        - 优点：加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响
        - 缺点：
            - 加减节点会造成哈希环中部分数据无法命中，需要手动处理或者忽略这部分数据，因此一致性哈希常用于缓存场景
            - 当使用少量节点时，节点变化将大范围影响哈希环中数据映射，因此这种方式不适合少量数据节点的分布式方案
            - 普通的一致性哈希分区在增减节点时需要增加一倍或减去一半节点才能保证数据和负载的均衡
    3. 有虚拟节点的一致性哈希分区：
    4. 虚拟槽分区（Redis Cluster就是采用虚拟槽分区）：虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot）。 这个范围一般远远大于节点数，比如Redis Cluster槽范围是0~
       16383。槽是集群内数据管理和迁移的基本单位。采用大范围槽的主要目的是为了方便数据拆分和集群扩展。每个节点会负责一定数量的槽

1. 集群数据结构
    - clusterNode
        - clusterNode结构保存了一个节点的当前状态，比如节点的创建时间、节点的名字、节点当前的配置纪元、节点的IP地址和端口号等等
        - 每个节点都会使用一个clusterNode结构来记录自己的状态，并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的clusterNode结构，以此来记录其他节点的状态
    - clusterLink
        - clusterNode结构的link属性是一个clusterLink结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区
    - clusterState
        - 每个节点都保存着一个clusterState结构，这个结构记录了在当前节点的视角下，集群目前所处的状态
2. Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽

### Redis架构模式

1. 单机模式
2. 主从模式(Redis Master+Redis Slave)（一主一从，一主多从）
    - master故障需要手动切换slave成为master
3. 主从(Redis Master+Redis Slave)+哨兵(Redis Sentinel)(高可用)
    - master故障时通过哨兵自动切换
4. 集群(Redis Cluster)（多主多从）
    - 横向扩展，数据分片
    - 集群自带高可用，master故障集群可以自己切换
5. 集群(Redis Cluster) + 哨兵(Redis Sentinel)


