[](http://redisbook.com/)

### 简单动态字符串（simple dynamic string，SDS）

```
struct sdshdr {

    // 记录 buf 数组中已使用字节的数量
    // 等于 SDS 所保存字符串的长度
    int len;

    // 记录 buf 数组中未使用字节的数量
    int free;

    // 字节数组，用于保存字符串
    char buf[];

};
```

- 结构定义
    1. len：存储的字符串长度，即buf 数组中已使用字节的数量
    2. free：可使用的字节长度
    3. buf：char 类型的数组，存储字符串内容，最后一个字节则保存了空字符 '\0'
        - buf数组长度=len+free+1
        - 遵循空字符结尾这一惯例的好处是， SDS 可以直接重用一部分 C 字符串函数库里面的函数

- SDS 与 C 字符串的区别![C 字符串和 SDS 之间的区别](/document/image/C字符串和SDS之间的区别.png)
    1. 常数复杂度获取字符串长度
        - C字符串没有记录长度，获取长度需要遍历，复杂度为 O(N)
        - SDS记录了长度len，SDS 获取长度的复杂度仅为 O(1)
    2. 杜绝缓冲区溢出
        - C 字符串需要手动扩展数组长度，因此容易造成缓冲区溢出（buffer overflow）
        - 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小，
          然后才执行实际的修改操作，不会出现缓冲区溢出问题
    3. 减少修改字符串时带来的内存重分配次数
        - 每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作
        - SDS 实现了空间预分配和惰性空间释放两种优化策略
            1. 空间预分配
                - 空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS
                  分配额外的未使用空间
                - 如果对 SDS 进行修改之后， len长度小于 1 MB ， 那么程序分配和 len 属性同样大小的未使用空间， 即free=len
                - 如果对 SDS 进行修改之后， len长度大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间。即free= 1 MB
                - 通过空间预分配策略， Redis 可以减少连续执行字符串增长操作所需的内存重分配次数
                - 在扩展 SDS 空间之前， SDS API 会先检查未使用空间是否足够， 如果足够的话， API 就会直接使用未使用空间， 而无须执行内存重分配
            2. 惰性空间释放
                - 惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free
                  属性将这些字节的数量记录起来， 并等待将来使用。
                - 通过惰性空间释放策略， SDS 避免了缩短字符串时所需的内存重分配操作， 并为将来可能有的增长操作提供了优化
                - 与此同时， SDS 也提供了相应的 API ， 让我们可以在有需要时， 真正地释放 SDS 里面的未使用空间， 所以不用担心惰性空间释放策略会造成内存浪费
    4. 二进制安全
        - C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据
        - SDS 的 API 都是二进制安全的（binary-safe）： 所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 ——
          数据在写入时是什么样的， 它被读取时就是什么样
        - 这也是我们将 SDS 的 buf 属性称为字节数组的原因 —— Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据
    5. 兼容部分 C 字符串函数
        - 通过遵循 C 字符串以空字符结尾的惯例， SDS 可以在有需要时重用 <string.h> 函数库， 从而避免了不必要的代码重复

### 链表

- 节点结构

```
typedef struct listNode {

    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;

} listNode;
```

- list结构(双向链表)

```
typedef struct list {

    // 表头节点
    listNode *head;

    // 表尾节点
    listNode *tail;

    // 链表所包含的节点数量
    unsigned long len;

    // 节点值复制函数
    void *(*dup)(void *ptr);

    // 节点值释放函数
    void (*free)(void *ptr);

    // 节点值对比函数
    int (*match)(void *ptr, void *key);

} list;
```

- 链表特性
    1. 链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。
    2. 每个链表节点由一个 listNode 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。
    3. 每个链表使用一个 list 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。
    4. 因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL ， 所以 Redis 的链表实现是无环链表。
    5. 通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。

### 字典， 又称符号表（symbol table）

Redis 的字典使用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对

1. 字典的实现
    - 哈希表

    ```
    typedef struct dictht {
    
        // 哈希表数组
        dictEntry **table;
    
        // 哈希表大小
        unsigned long size;
    
        // 哈希表大小掩码，用于计算索引值
        // 总是等于 size - 1
        unsigned long sizemask;
    
        // 该哈希表已有节点的数量
        unsigned long used;
    
    } dictht;
    ```

    - 哈希表节点

      ```
      typedef struct dictEntry {
  
          // 键
          void *key;
  
          // 值
          union {
              void *val;
              uint64_t u64;
              int64_t s64;
          } v;
  
          // 指向下个哈希表节点，形成链表（解决键冲突（collision）的问题）
          struct dictEntry *next;
  
      } dictEntry;
      ```

    - 字典

    ```
    typedef struct dict {
    
        // 类型特定函数
        dictType *type;
    
        // 私有数据
        void *privdata;
    
        // 哈希表
        dictht ht[2];
    
        // rehash 索引
        // 当 rehash 不在进行时，值为 -1
        int rehashidx; /* rehashing not in progress if rehashidx == -1 */
    
    } dict;
    ```

         1. type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。
         1. 而 privdata 属性则保存了需要传给那些类型特定函数的可选参数
         2. ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。
         3. 除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。

    ```
    typedef struct dictType {
    
        // 计算哈希值的函数
        unsigned int (*hashFunction)(const void *key);
    
        // 复制键的函数
        void *(*keyDup)(void *privdata, const void *key);
    
        // 复制值的函数
        void *(*valDup)(void *privdata, const void *obj);
    
        // 对比键的函数
        int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    
        // 销毁键的函数
        void (*keyDestructor)(void *privdata, void *key);
    
        // 销毁值的函数
        void (*valDestructor)(void *privdata, void *obj);
    
    } dictType;
    ```

2. 哈希算法
    - 当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。
3. 解决键冲突
    - Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表，
      被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题
    - 因为 dictEntry 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 O(1)）， 排在其他已有节点的前面
4. rehash（负载因子 = 哈希表已保存节点数量 / 哈希表大小）
    - 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩，步骤如下：
        1. 为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）：
            - 如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；
            - 如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。
        2. 将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。
        3. 当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash
           做准备。
    - 哈希表的扩展与收缩
        1. 当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作
            - 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；
            - 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；
        2. 当哈希表的负载因子小于 0.1 时， 程序自动开始对哈希表执行收缩操作
    - 在执行 BGSAVE 命令或 BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，
      所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存
5. 渐进式 rehash
    - 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1]
        1. 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。
        2. 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。
        3. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当
           rehash 工作完成之后， 程序将 rehashidx 属性的值增一。
        4. 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。
    - 渐进式 rehash 执行期间的哈希表操作
        1. 因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间，
           字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1]
           里面进行查找， 诸如此类。
        2. 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash
           操作的执行而最终变成空表。

### 跳跃表（skiplist）

- 跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的
- Redis 使用跳跃表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多， 又或者有序集合中元素的成员（member）是比较长的字符串时， Redis 就会使用跳跃表来作为有序集合键的底层实现

### 整数集合（intset）

1. 结构

    ```
    typedef struct intset {
    
        // 编码方式
        uint32_t encoding;
    
        // 集合包含的元素数量
        uint32_t length;
    
        // 保存元素的数组
        int8_t contents[];
    
    } intset;
    ```

    - contents 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。
    - length 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。
    - contents 数组的真正类型取决于 encoding 属性的值：
        1. INTSET_ENC_INT16 ，（最小值为 -32,768 ，最大值为 32,767 ）。
        2. INTSET_ENC_INT32 ，（最小值为 -2,147,483,648 ，最大值为 2,147,483,647 ）。
        3. INTSET_ENC_INT64 ，（最小值为 -9,223,372,036,854,775,808 ，最大值为 9,223,372,036,854,775,807 ）

2. 升级
    - 当添加的新元素类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。
        1. 根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。
        2. 将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。
        3. 将新元素添加到底层数组里面。
    - 整数集合的升级策略有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存
3. 降级
    - 整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态

### 压缩列表（ziplist）

- 压缩列表是一种为节约内存而开发的连续内存块组成的顺序型数据结构。
- 压缩列表被用作列表键和哈希键的底层实现之一。
- 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。
- 添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。

### 对象

- Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）
- 对象结构
    ```
    typedef struct redisObject {
    
        // 类型
        unsigned type:4;
    
        // 编码
        unsigned encoding:4;
    
        // 指向底层实现数据结构的指针
        void *ptr;
    
        // ...
    
    } robj;
    ```
- 对象类型（type的值）
    1. REDIS_STRING 字符串对象
    2. REDIS_LIST 列表对象
    3. REDIS_HASH 哈希对象
    4. REDIS_SET 集合对象
    5. REDIS_ZSET 有序集合对象
- 对象编码
    1. 字符串对象
        - 当值为数字
        - 当值为字符串


