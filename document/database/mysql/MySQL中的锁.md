### 行锁

1. 共享锁（S Lock），允许事务读一行数据
2. 排他锁（X Lock），允许事务删除或更新一行数据
3. 行锁的三种算法
    1. Record Lock：单个行记录上的锁
    2. Gap Lock：间隙锁，锁定一个范围，但不包含记录本身
    3. Next-Key Lock=Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身（解决幻读）

### 表锁

1. 意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁
2. 意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁”
3. 自增长锁AUTO-INC Locking。这种锁其实是采用一种特殊的表锁机制，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即释放

### 锁的兼容

| |  IS | IX | S | X |
|---|----|----|---|---|
| IS | 兼容 |兼容 | 兼容 | 不兼容 |
| IX| 兼容 | 兼容 | 不兼容 | 不兼容 |
| S | 兼容 | 不兼容 | 兼容 | 不兼容 |
| X | 不兼容 | 不兼容 | 不兼容 | 不兼容 |

### 一致性非锁定读和一致性锁定读

1. 事务的隔离级别为REPEATABLE READ模式下，InnoDB存储引擎的SELECT操作使用一致性非锁定读
2. InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读（locking read）操作：
    - SELECT…FOR UPDATE：会加IX表锁和X行锁（条件是主键的时候）
    - SELECT…LOCK IN SHARE MODE：会加IS表锁和S行锁（条件是主键的时候）
    - SELECT…FOR UPDATE对读取的行记录加一个X锁，其他事务不能对已锁定的行加上任何锁
    - SELECT…LOCK IN SHARE MODE对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞

### 死锁

1. 概念：死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象
2. 解决死锁
    - 超时机制：当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行
    - wait-for graph（等待图）wait-for graph要求数据库保存以下两种信息：
        - 锁的信息链表
        - 事务等待链表
        - wait-for graph是一种较为主动的死锁检测机制，在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务

      

