### 查询过程
    1.对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录。
    2.对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。
    
    InnoDB 的数据是按数据页为单位来读写的。
    也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。
    在 InnoDB 中，每个数据页的大小默认是 16KB。

### 更新过程
       当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，
    InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，
    将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。
       将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。
    除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。
    
### 什么条件下可以使用 change buffer 呢？
       对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。
    比如，要插入记录，就要先判断现在表中是否已经存在该记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。
    因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。
       change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。
    这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。
    
### change buffer 的使用场景
    对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。
    
### 索引选择和实践
    普通索引和唯一索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以尽量选择普通索引。
    如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能
    
### change buffer 和 redo log
    redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。
    
### 如果某次写入使用了 change buffer 机制，之后主机异常重启，是否会丢失 change buffer 和数据
    不会丢失。虽然是只更新内存，但是在事务提交的时候，我们把 change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时候，change buffer 也能找回来。
    
### merge 的执行流程是：
    1.从磁盘读入数据页到内存（老版本的数据页）；
    2.从 change buffer 里找出这个数据页的 change buffer 记录 (可能有多个），依次应用，得到新版数据页；
    3.写 redo log。这个 redo log 包含了数据的变更和 change buffer 的变更
    merge 过程结束后，数据页和内存中 change buffer 对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了